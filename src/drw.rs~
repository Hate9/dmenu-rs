use libc::{c_uint, c_int};
use x11::xlib::{Display, Window, Drawable, GC, XCreateGC, XCreatePixmap, XSetLineAttributes,
		XDefaultDepth, XWindowAttributes, JoinMiter, CapButt, LineSolid,
		XDefaultColormap, XDefaultVisual};
use x11::xft::{XftFont, XftColor, FcPattern, XftFontOpenPattern, XftFontOpenName, XftFontClose, XftNameParse, XftColorAllocName};
use x11::xrender::XRenderColor;
use fontconfig::fontconfig::{FcResultMatch, FcPatternGetBool, FcBool};
use std::ptr;
use std::ffi::{CString, CStr, c_void};
use libc::c_char;

use std::mem::{self, MaybeUninit};

use crate::config::{COLORS, Schemes};

type Clr = XftColor;

#[derive(Debug)]
struct Fnt {
    xfont: *mut XftFont,
    pattern_pointer: *mut FcPattern,
    height: i32,
}

impl Fnt {
    // xfont_create
    pub fn new(drw: &Drw, fontname: *mut c_char, pattern: Option<*mut FcPattern>) -> Option<Self> {
	unsafe {
	    let xfont;
	    if fontname != ptr::null_mut() {
		/* Using the pattern found at font->xfont->pattern does not yield the
		 * same substitution results as using the pattern returned by
		 * FcNameParse; using the latter results in the desired fallback
		 * behaviour whereas the former just results in missing-character
		 * rectangles being drawn, at least with some fonts. */
		xfont = XftFontOpenName(drw.dpy, drw.screen, fontname);
		if xfont == ptr::null_mut() {
		    eprintln!("error, cannot load font from name: '%s'\n");
		    return None;
		}
		let pattern = XftNameParse(fontname);
		if pattern == ptr::null_mut() {
		    let c_str: &CStr = CStr::from_ptr(fontname);
		    let str_slice: &str = c_str.to_str().unwrap();
		    eprintln!("error, cannot parse font name to pattern: '{}'", str_slice);
		    XftFontClose(drw.dpy, xfont);
		    return None;
		}
	    } else if pattern.is_some() {
		xfont = XftFontOpenPattern(drw.dpy, pattern.unwrap());
		if xfont == ptr::null_mut() {
		    eprintln!("error, cannot load font from pattern.");
		    return None;
		}
	    } else {
		panic!("No font specified.");
	    }

	    /* Do not allow using color fonts. This is a workaround for a BadLength
	     * error from Xft with color glyphs. Modelled on the Xterm workaround. See
	     * https://bugzilla.redhat.com/show_bug.cgi?id=1498269
	     * https://lists.suckless.org/dev/1701/30932.html
	     * https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=916349
	     * and lots more all over the internet.
	     */

	    let iscol = MaybeUninit::uninit().assume_init();
	    let fc_color = MaybeUninit::uninit().assume_init();
	    let mut pattern_pointer =
		if pattern.is_some() {
		    pattern.unwrap() as *mut c_void
		} else {
		    ptr::null_mut()
		};
	    if(FcPatternGetBool(pattern_pointer, fc_color, 0, iscol) == FcResultMatch && *iscol != 0) {
		XftFontClose(drw.dpy, xfont);
		return None;
	    }

	    let height = (*xfont).ascent+(*xfont).descent;

	    return Some(Self{xfont, pattern_pointer: pattern_pointer as *mut FcPattern, height: height});
	}
    }
}

#[derive(Debug)]
pub struct Drw {
    wa: XWindowAttributes,
    dpy: *mut Display,
    screen: c_int,
    root: Window,
    drawable: Drawable,
    gc: GC,
    scheme: Clr,
    fonts: Vec<Fnt>,
    schemeset: [*mut Clr; Schemes::SchemeLast as usize] // replacement for "scheme"
}

impl Drw {
    pub fn new(dpy: *mut Display, screen: c_int, root: Window, wa: XWindowAttributes) -> Self {
	unsafe {
	    let drawable = XCreatePixmap(dpy, root, wa.width as u32, wa.height as u32, XDefaultDepth(dpy, screen) as u32);
	    let gc = XCreateGC(dpy, root, 0, ptr::null_mut());
	    XSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);
	    let fonts = Vec::new();
	    let mut ret = Self{wa, dpy, screen, root, drawable, gc, fonts: fonts, scheme: MaybeUninit::uninit().assume_init(), schemeset: MaybeUninit::uninit().assume_init()};

	    for j in 0..(Schemes::SchemeLast as usize) {
		ret.schemeset[j] = ret.scm_create(COLORS[j]);
	    }
	    
	    ret
	}
    }

    pub fn fontset_create(&mut self, fonts: Vec<*mut c_char>) -> bool {
	if fonts.len() == 0 {
	    return false;
	}

	for font in fonts.into_iter().rev() {
	    let to_push = Fnt::new(self, font, None);
	    if to_push.is_some() {
		self.fonts.push(to_push.unwrap());
	    }
	}

	true
    }

    pub fn scm_create(&self, clrnames: [[u8; 8]; 2]) -> *mut Clr {
	/* need at least two colors for a scheme */
	if clrnames.len() < 2 {
	    return ptr::null_mut();
	}
	
	let ret: *mut Clr = unsafe{ MaybeUninit::uninit().assume_init() };
	for clrname in clrnames.iter() {
	    self.clr_create(ret, clrname.as_ptr() as *const c_char);
	}
	ret
    }

    fn clr_create(&self, dest: *mut Clr, clrname: *const c_char) {
	unsafe {
	    if clrname == ptr::null_mut() {
		return;
	    }
	    if (XftColorAllocName(self.dpy, XDefaultVisual(self.dpy, self.screen), XDefaultColormap(self.dpy, self.screen), clrname, dest)==0) {
		panic!("error, cannot allocate color {:?}", CStr::from_ptr(clrname));
	    }
	}
    }
}
